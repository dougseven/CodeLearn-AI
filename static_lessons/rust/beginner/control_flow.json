{
    "lesson": "# Control Flow in Rust\n\n## Introduction\nControl flow determines the order in which code is executed in a program. In Rust, you have several powerful mechanisms to control program execution.\n\n## Conditional Statements\n\n### If-Else Statements\n```rust\nfn main() {\n    let number = 7;\n    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n}\n```\n\n### Match Expressions\n```rust\nfn main() {\n    let x = 3;\n    match x {\n        1 => println!(\"one\"),\n        2 => println!(\"two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"something else\"),\n    }\n}\n```\n\n## Loops\n\n### For Loops\n```rust\nfn main() {\n    for number in 1..5 {\n        println!(\"{}!\", number);\n    }\n}\n```\n\n## Key Points\n- Rust uses `if`, `else if`, and `else` for conditionals\n- `match` provides powerful pattern matching\n- Loops include `for`, `while`, and `loop`\n- Rust enforces strict type checking in control flow\n\n## Common Mistakes\n- Forgetting type conversions\n- Not handling all possible match cases\n- Infinite loops without break conditions\n\n## Practice Exercises\n1. Write a function that uses match to classify numbers\n2. Create a loop that prints fibonacci sequence\n3. Implement a control flow that handles multiple conditions",
    "challenge": "// Create a function that determines the classification of a number\n// Requirements:\n// 1. Use match expression\n// 2. Classify numbers as: 'Positive', 'Negative', or 'Zero'\n// 3. Return the classification as a string\n\nfn classify_number(num: i32) -> String {\n    // Your implementation here\n}",
    "tests": [
        "fn test_number_classification() {\n    assert_eq!(classify_number(5), \"Positive\");\n    assert_eq!(classify_number(-3), \"Negative\");\n    assert_eq!(classify_number(0), \"Zero\");\n}",
        "fn test_zero_case() {\n    assert_eq!(classify_number(0), \"Zero\");\n}",
        "fn test_large_numbers() {\n    assert_eq!(classify_number(1000), \"Positive\");\n    assert_eq!(classify_number(-1000), \"Negative\");\n}"
    ]
}