{
    "lesson": "# Variables and Mutability in Rust\n\n## Introduction\nRust provides a unique approach to variable management, emphasizing memory safety and preventing unexpected mutations.\n\n## Concept Overview\nIn Rust, variables are immutable by default, which means once a value is assigned, it cannot be changed without explicit permission.\n\n## Syntax\n\n```rust\n// Immutable variable (default behavior)\nlet x = 5; // Cannot be changed\n// x = 6; // This would cause a compile-time error\n\n// Mutable variable\nlet mut y = 10; // Can be modified\ny = 15; // This is allowed\n\n// Shadowing: creating a new variable with same name\nlet z = 20;\nlet z = z + 5; // Creates a new immutable binding\n```\n\n## Key Points\n- Variables are immutable by default\n- Use `mut` keyword to create mutable variables\n- Shadowing allows creating new variable bindings\n- Immutability helps prevent unintended state changes\n\n## Common Mistakes\n- Trying to modify an immutable variable\n- Forgetting to use `mut` when needing to change a value\n- Overusing mutability when immutable variables would suffice\n\n## Practice\n\n```rust\n// Exercise: Create a temperature conversion function\nfn convert_temperature(celsius: f64) -> f64 {\n    // TODO: Implement Celsius to Fahrenheit conversion\n}\n```\n",
    "challenge": "Create a function that demonstrates variable mutability and shadowing in Rust.\n\nRequirements:\n1. Create an immutable variable with an initial value\n2. Shadow the variable with a new value\n3. Create a mutable variable and modify its value\n4. Return the final value\n\nYour implementation should showcase Rust's variable behavior.",
    "tests": [
        "fn test_basic_mutability() {\n    // Test immutability and shadowing\n    assert!(true);\n}",
        "fn test_mutable_variable() {\n    // Test mutable variable modification\n    assert!(true);\n}",
        "fn test_variable_shadowing() {\n    // Test variable shadowing behavior\n    assert!(true);\n}"
    ]
}