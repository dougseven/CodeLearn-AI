{
    "lesson": "# Building and Packaging Python Applications\n\n## Introduction\nAdvanced Python application packaging involves creating distributable, installable software that can be easily shared and deployed across different environments.\n\n## Packaging Concepts\nPython packaging transforms code into a structured, distributable format using tools like setuptools and poetry. Compared to C# NuGet packaging, Python offers more flexible distribution mechanisms.\n\n## Key Packaging Components\n- `setup.py`: Project configuration and metadata\n- `pyproject.toml`: Modern dependency and build configuration\n- `requirements.txt`: Dependency specification\n- Wheel (`.whl`) and source distribution formats\n\n## Advanced Packaging Techniques\n```python\n# setup.py example\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='myproject',\n    version='1.0.0',\n    packages=find_packages(),\n    install_requires=[\n        'requests>=2.25.1',\n        'pandas'\n    ]\n)\n```\n\n```python\n# pyproject.toml with poetry\n[tool.poetry]\nname = 'advanced-project'\nversion = '0.1.0'\ndescription = 'Advanced Python Package'\n\n[tool.poetry.dependencies]\npython = '^3.8'\nrequests = '^2.25.1'\n```\n\n## Key Points\n- Use virtual environments for dependency isolation\n- Leverage `setuptools` for complex packaging\n- Support multiple Python versions\n- Include metadata and documentation\n- Use semantic versioning\n\n## Common Packaging Mistakes\n- Incomplete dependency specification\n- Ignoring platform-specific requirements\n- Neglecting version compatibility\n- Poor documentation\n\n## Practice Exercises\n1. Create a package with multiple modules\n2. Implement version-specific dependencies\n3. Build a distributable wheel package\n\n## Advanced Techniques\n- Implement namespace packages\n- Create platform-specific wheels\n- Use continuous integration for automated builds\n",
    "challenge": "def create_package_configuration(project_name, version, dependencies):\n    \"\"\"\n    Create a comprehensive package configuration dictionary.\n    \n    Requirements:\n    1. Generate a configuration dictionary with project metadata\n    2. Include name, version, and dependency list\n    3. Add optional description and author fields\n    4. Validate input types and handle potential errors\n    \n    Returns:\n    dict: Comprehensive package configuration\n    \"\"\"\n    pass\n",
    "tests": [
        "def test_package_configuration_basic(solution):\n    config = solution.create_package_configuration('myproject', '1.0.0', ['requests'])\n    assert config['name'] == 'myproject'\n    assert config['version'] == '1.0.0'\n    assert 'requests' in config['dependencies']",
        "def test_package_configuration_validation(solution):\n    try:\n        solution.create_package_configuration(123, '1.0.0', [])\n        assert False, 'Should raise TypeError for invalid project name'\n    except TypeError:\n        assert True",
        "def test_package_configuration_complete(solution):\n    config = solution.create_package_configuration('advanced_pkg', '0.2.1', ['pandas', 'numpy'], description='Data processing toolkit')\n    assert 'description' in config\n    assert config['description'] == 'Data processing toolkit'"
    ]
}