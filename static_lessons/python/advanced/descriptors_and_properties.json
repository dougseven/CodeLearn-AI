{
    "lesson": "# Python Descriptors and Properties: Advanced Deep Dive\n\n## Introduction\n\nDescriptors are a powerful mechanism in Python for customizing attribute access, providing fine-grained control over object attribute behavior. They represent the core of how methods, properties, and class attributes work under the hood.\n\n## Concept Overview\n\nIn Python, descriptors are classes implementing at least one of three special methods:\n- `__get__(self, instance, owner)`\n- `__set__(self, instance, value)`\n- `__delete__(self, instance)`\n\n## Syntax and Examples\n\n```python\nclass DescriptorExample:\n    def __get__(self, instance, owner):\n        # Control attribute retrieval\n        return self._value\n\n    def __set__(self, instance, value):\n        # Control attribute assignment\n        self._value = value\n```\n\n```python\n# Property Decorator Equivalent\nclass Temperature:\n    def __init__(self):\n        self._celsius = 0\n\n    @property\n    def fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n\n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        self._celsius = (value - 32) * 5/9\n```\n\n## Key Points\n\n- Descriptors control attribute access and modification\n- Can implement validation, computed properties, and lazy loading\n- `@property` is a built-in descriptor implementation\n- Descriptors are used extensively in Python's internals\n\n## Comparison with C#\n\n- Python Descriptors \u2248 C# Property Accessors\n- Python `@property` \u2248 C# `{ get; set; }` syntax\n- More dynamic and flexible in Python\n\n## Common Mistakes\n\n- Forgetting to implement all three descriptor methods\n- Not handling `None` cases for `instance`\n- Circular reference in descriptor logic\n\n## Advanced Use Cases\n\n```python\nclass ValidatedInteger:\n    def __init__(self, min_value=0, max_value=100):\n        self.min_value = min_value\n        self.max_value = max_value\n        self._value = None\n\n    def __get__(self, instance, owner):\n        return self._value\n\n    def __set__(self, instance, value):\n        if not isinstance(value, int):\n            raise TypeError('Must be an integer')\n        if value < self.min_value or value > self.max_value:\n            raise ValueError(f'Value must be between {self.min_value} and {self.max_value}')\n        self._value = value\n```\n\n## Practice Exercises\n\n1. Create a descriptor that logs all attribute changes\n2. Implement a read-only descriptor\n3. Build a descriptor for type-checking attributes",
    "challenge": "# Challenge: Create a Validated Property Descriptor\n\nImplement a descriptor class `RangeDescriptor` that:\n1. Validates integer values within a specified range\n2. Allows custom min and max values\n3. Provides meaningful error messages\n4. Works with multiple class instances\n\nRequirements:\n- Support integer values only\n- Enforce min and max range\n- Raise appropriate exceptions for invalid inputs\n- Allow flexible range configuration\n\ndef create_range_descriptor(min_val, max_val):\n    # TODO: Implement the range descriptor\n    pass",
    "tests": [
        "def test_range_descriptor():\n    class Person:\n        age = create_range_descriptor(0, 120)\n\n    p = Person()\n    p.age = 30  # Should pass\n    assert p.age == 30\n\n    with pytest.raises(ValueError):\n        p.age = 150  # Should raise ValueError\n\ndef test_range_descriptor_type():\n    class Person:\n        age = create_range_descriptor(0, 120)\n\n    p = Person()\n    with pytest.raises(TypeError):\n        p.age = '30'  # Should raise TypeError\n\ndef test_range_descriptor_multiple_instances():\n    class Person:\n        age = create_range_descriptor(0, 120)\n\n    p1 = Person()\n    p2 = Person()\n    p1.age = 25\n    p2.age = 35\n    assert p1.age == 25\n    assert p2.age == 35"
    ]
}