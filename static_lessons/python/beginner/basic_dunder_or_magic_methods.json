{
    "lesson": "# Python Dunder (Magic) Methods\n\n## Introduction\n\nDunder methods, also known as magic methods, are special predefined methods in Python that have double underscores before and after their names. These methods allow you to define how objects of a class behave in various situations.\n\n## Concept Overview\n\nMagic methods enable you to customize object behavior, such as:\n- Object initialization\n- String representation\n- Comparison operations\n- Arithmetic operations\n- Container-like behaviors\n\n## Syntax\n\n```python\nclass MyClass:\n    def __init__(self, value):\n        # Constructor method\n        self.value = value\n    \n    def __str__(self):\n        # String representation method\n        return f'MyClass with value: {self.value}'\n```\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __eq__(self, other):\n        # Custom equality comparison\n        return self.x == other.x and self.y == other.y\n```\n\n## Key Points\n\n- Dunder methods start and end with double underscores\n- They define special behaviors for objects\n- Common dunder methods include:\n  - `__init__()`: Constructor\n  - `__str__()`: String representation\n  - `__repr__()`: Detailed string representation\n  - `__eq__()`: Equality comparison\n  - `__add__()`: Addition operation\n\n## Common Mistakes\n\n- Forgetting to implement required parameters\n- Misunderstanding the purpose of specific magic methods\n- Overcomplicating method implementations\n\n## Practice\n\n```python\n# Exercise: Implement a custom class with magic methods\nclass Book:\n    def __init__(self, title, author, pages):\n        # TODO: Implement initialization\n        pass\n    \n    def __str__(self):\n        # TODO: Return a string representation\n        pass\n    \n    def __len__(self):\n        # TODO: Return number of pages\n        pass\n```\n\n**Hint**: Think about how you want your object to behave when converted to a string or when its length is requested.",
    "challenge": "# Implement a custom Point class with magic methods\n\nCreate a Point class that supports:\n1. Initialization with x and y coordinates\n2. String representation\n3. Equality comparison\n4. Addition of two points\n\nRequirements:\n- Constructor should accept x and y coordinates\n- __str__() should return a formatted string\n- __eq__() should compare points based on coordinates\n- __add__() should return a new point with summed coordinates\n\nExample usage:\n```python\np1 = Point(1, 2)\np2 = Point(3, 4)\nprint(p1)  # Should print: Point(1, 2)\nprint(p1 + p2)  # Should print: Point(4, 6)\n```",
    "tests": [
        "def test_point_creation():\n    p = Point(1, 2)\n    assert p.x == 1\n    assert p.y == 2\n\ndef test_point_string_representation():\n    p = Point(3, 4)\n    assert str(p) == 'Point(3, 4)'\n\ndef test_point_equality():\n    p1 = Point(1, 2)\n    p2 = Point(1, 2)\n    p3 = Point(3, 4)\n    assert p1 == p2\n    assert p1 != p3\n\ndef test_point_addition():\n    p1 = Point(1, 2)\n    p2 = Point(3, 4)\n    p3 = p1 + p2\n    assert p3.x == 4\n    assert p3.y == 6"
    ]
}