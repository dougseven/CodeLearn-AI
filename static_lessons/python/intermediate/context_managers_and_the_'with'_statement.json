{
    "lesson": "# Context Managers and the 'with' Statement\n\n## Introduction\nContext managers in Python provide a clean way to handle resource management, especially for operations that require setup and cleanup, like file handling.\n\n## Concept Overview\nA context manager ensures that resources are properly managed by automatically handling initialization and cleanup operations. The 'with' statement makes using context managers simple and readable.\n\n## Syntax\n```python\n# Basic file handling with context manager\nwith open('example.txt', 'r') as file:\n    content = file.read()\n# File is automatically closed after the block\n```\n\n```python\n# Creating a custom context manager using class\nclass MyContext:\n    def __enter__(self):\n        print('Starting')\n        return self\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        print('Cleaning up')\n\nwith MyContext():\n    print('Doing work')\n```\n\n## Key Points\n- Context managers automatically handle cleanup\n- The 'with' statement makes resource management more readable\n- Common uses include file operations and database connections\n- Prevents resource leaks and ensures proper cleanup\n\n## Common Mistakes\n- Forgetting to use 'with' for file operations\n- Not implementing both __enter__ and __exit__ methods\n- Trying to access managed resources after the 'with' block\n\n## Practice\nTry creating a simple context manager:\n```python\n# Create a context manager that times a block of code\nfrom time import time\n\nclass Timer:\n    def __enter__(self):\n        self.start = time()\n        return self\n        \n    def __exit__(self, *args):\n        self.end = time()\n        print(f'Time taken: {self.end - self.start} seconds')\n```",
    "challenge": "# Create a context manager called DatabaseConnection that simulates connecting to and disconnecting from a database\n\nclass DatabaseConnection:\n    def __enter__(self):\n        # Simulate connecting to database\n        pass\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        # Simulate disconnecting from database\n        pass\n    \n    def query(self, sql):\n        # Simulate executing a query\n        pass",
    "tests": [
        "def test_database_connection_context():\n    with DatabaseConnection() as db:\n        assert hasattr(db, 'query'), 'DatabaseConnection should have a query method'\n",
        "def test_database_connection_cleanup():\n    db = DatabaseConnection()\n    with db:\n        pass\n    assert not hasattr(db, '_connected'), 'Database should be disconnected after context'",
        "def test_database_connection_error_handling():\n    with pytest.raises(ValueError):\n        with DatabaseConnection() as db:\n            raise ValueError('Test error handling')\n    assert not hasattr(db, '_connected'), 'Should cleanup even after error'"
    ]
}