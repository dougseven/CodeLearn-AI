{
    "lesson": "# Object Oriented Design Patterns in Python\n\n## Introduction\nDesign patterns are reusable solutions to common software design problems. In Python, these patterns are implemented differently than in strictly typed languages like C#, but the core concepts remain the same.\n\n## Common Design Patterns\n\n### 1. Singleton Pattern\nEnsures a class has only one instance. In Python, this can be achieved through metaclasses or decorators.\n\n```python\nclass Singleton:\n    _instance = None\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n```\n\n### 2. Factory Pattern\nCreates objects without explicitly specifying their exact classes.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self): pass\n\nclass Dog(Animal):\n    def speak(self): return 'Woof!'\n\nclass AnimalFactory:\n    @staticmethod\n    def create_animal(animal_type):\n        if animal_type == 'dog':\n            return Dog()\n```\n\n## Key Points\n- Python's dynamic nature makes some patterns simpler than in C#\n- Patterns should be used judiciously - don't overengineer\n- Focus on readability and maintainability\n\n## Common Mistakes\n- Overusing patterns where simple code would suffice\n- Not considering Python's built-in features first\n- Directly copying patterns from static languages\n\n## Practice\nImplement an Observer pattern to notify subscribers of state changes.",
    "challenge": "# Implement a simple Observer pattern\n\nclass Subject:\n    def __init__(self):\n        self._observers = []\n        self._state = None\n\n    def attach(self, observer):\n        pass  # TODO: Implement attaching observer\n\n    def detach(self, observer):\n        pass  # TODO: Implement detaching observer\n\n    def notify(self):\n        pass  # TODO: Implement notification\n\n    @property\n    def state(self):\n        return self._state\n\n    @state.setter\n    def state(self, value):\n        self._state = value\n        self.notify()\n",
    "tests": [
        "def test_attach_observer():\n    subject = Subject()\n    observer = lambda x: x\n    subject.attach(observer)\n    assert len(subject._observers) == 1",
        "def test_detach_observer():\n    subject = Subject()\n    observer = lambda x: x\n    subject.attach(observer)\n    subject.detach(observer)\n    assert len(subject._observers) == 0",
        "def test_notify_observers():\n    subject = Subject()\n    results = []\n    observer = lambda x: results.append(x)\n    subject.attach(observer)\n    subject.state = 'test'\n    assert results[0] == 'test'"
    ]
}