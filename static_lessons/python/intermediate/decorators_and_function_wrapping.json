{
    "lesson": "# Python Decorators and Function Wrapping\n\n## Introduction\nDecorators are a powerful way to modify or enhance functions without directly changing their source code. In C#, this pattern is similar to Attributes and Middleware, though Python's implementation is more flexible.\n\n## Concept Overview\nA decorator is a function that takes another function as input and extends its behavior without explicitly modifying it. It wraps the original function, adding functionality before or after its execution.\n\n## Syntax\n```python\n# Basic decorator\ndef my_decorator(func):\n    def wrapper():\n        print('Before function')\n        func()\n        print('After function')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('Hello!')\n```\n\n```python\n# Decorator with parameters\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f'Hello {name}')\n```\n\n## Key Points\n- Decorators follow the Wrapper Pattern\n- Use @functools.wraps to preserve function metadata\n- Decorators can be stacked\n- They can accept parameters using nested functions\n\n## Common Mistakes\n- Forgetting to return the wrapper function\n- Not handling function arguments correctly\n- Losing function metadata without @functools.wraps\n\n## Practice\nTry creating:\n1. A timing decorator that measures function execution time\n2. A logging decorator that records function calls\n3. A retry decorator that attempts to execute a function multiple times\n",
    "challenge": "# Create a retry decorator that attempts to execute a function up to 3 times if it raises an exception\n\ndef retry_decorator(func):\n    pass\n    # Your implementation here\n    # Should retry the function up to 3 times if it raises an exception\n    # Return the result if successful\n    # Raise the last exception if all attempts fail\n",
    "tests": [
        "def test_successful_execution():\n    @retry_decorator\n    def success_func():\n        return 'success'\n    assert success_func() == 'success'",
        "def test_retry_failure():\n    attempt_count = 0\n    @retry_decorator\n    def fail_func():\n        nonlocal attempt_count\n        attempt_count += 1\n        raise ValueError('Test error')\n    try:\n        fail_func()\n    except ValueError:\n        assert attempt_count == 3",
        "def test_eventual_success():\n    attempt_count = 0\n    @retry_decorator\n    def eventual_success():\n        nonlocal attempt_count\n        attempt_count += 1\n        if attempt_count < 2:\n            raise ValueError('Temporary error')\n        return 'success'\n    assert eventual_success() == 'success'"
    ]
}