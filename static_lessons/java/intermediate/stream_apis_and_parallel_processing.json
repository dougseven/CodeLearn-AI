{
    "lesson": "# Stream APIs and Parallel Processing in Java\n\n## Introduction\nStream APIs and parallel processing represent powerful techniques in Java for handling large-scale data transformations and computational tasks efficiently.\n\n## Concept Overview\nJava Streams provide a declarative approach to processing collections, enabling functional-style operations. Parallel streams leverage multi-core processors to execute operations concurrently.\n\n## Syntax and Examples\n\n```java\n// Sequential Stream Processing\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream()\n                 .filter(n -> n % 2 == 0)\n                 .mapToInt(n -> n)\n                 .sum();\n```\n\n```java\n// Parallel Stream Processing\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList<String> upperNames = names.parallelStream()\n                               .map(String::toUpperCase)\n                               .collect(Collectors.toList());\n```\n\n## Key Points\n- Streams are lazily evaluated\n- Parallel streams use ForkJoinPool\n- Not suitable for small datasets\n- Stateless operations are thread-safe\n\n## Comparison with C#\n- Java Stream \u2248 C# LINQ\n- `parallelStream()` \u2248 `AsParallel()` in LINQ\n- Both support functional transformations\n\n## Common Mistakes\n- Overusing parallel streams\n- Modifying shared state in stream operations\n- Ignoring order in parallel processing\n\n## Practice Exercises\n1. Create a parallel stream to filter and transform data\n2. Implement a performance comparison between sequential and parallel streams\n\n## Performance Considerations\n- Overhead of creating parallel streams\n- Complexity of underlying data structure\n- Number of available processor cores",
    "challenge": "public class StreamProcessingChallenge {\n    public static List<String> processDataParallel(List<String> input) {\n        // TODO: Implement parallel stream processing\n        // Requirements:\n        // 1. Convert all strings to uppercase\n        // 2. Filter strings longer than 3 characters\n        // 3. Sort the result alphabetically\n        // 4. Return processed list\n        return null;\n    }\n}",
    "tests": [
        "import static org.junit.Assert.*;\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class StreamProcessingTest {\n    @Test\n    public void testBasicProcessing() {\n        List<String> input = Arrays.asList(\"apple\", \"banana\", \"cat\", \"dog\");\n        List<String> result = StreamProcessingChallenge.processDataParallel(input);\n        assertEquals(3, result.size());\n    }",
        "\n    @Test\n    public void testUppercaseAndFiltering() {\n        List<String> input = Arrays.asList(\"a\", \"apple\", \"banana\", \"cat\");\n        List<String> result = StreamProcessingChallenge.processDataParallel(input);\n        assertTrue(result.contains(\"APPLE\"));\n        assertTrue(result.contains(\"BANANA\"));\n        assertFalse(result.contains(\"A\"));\n    }",
        "\n    @Test\n    public void testEmptyInput() {\n        List<String> input = Arrays.asList();\n        List<String> result = StreamProcessingChallenge.processDataParallel(input);\n        assertTrue(result.isEmpty());\n    }"
    ]
}